<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>DDD: GHom Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">DDD
   &#160;<span id="projectnumber">1.9.0.20180227174329</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classGHom-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">GHom Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class is the base class representing a homomorphism over <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams. ">DDD</a>.  
 <a href="classGHom.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Hom_8h_source.html">Hom.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for GHom:</div>
<div class="dyncontent">
<div class="center"><img src="classGHom__inherit__graph.png" border="0" usemap="#GHom_inherit__map" alt="Inheritance graph"/></div>
<map name="GHom_inherit__map" id="GHom_inherit__map">
</map>
</div>
<div class="dynheader">
Collaboration diagram for GHom:</div>
<div class="dyncontent">
<div class="center"><img src="classGHom__coll__graph.png" border="0" usemap="#GHom_coll__map" alt="Collaboration graph"/></div>
<map name="GHom_coll__map" id="GHom_coll__map">
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa6dc06d4106df676eeffdd02a24928ea"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classGDDD.html">GDDD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#aa6dc06d4106df676eeffdd02a24928ea">NodeType</a></td></tr>
<tr class="separator:aa6dc06d4106df676eeffdd02a24928ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb7a403f294a57ca86da7ec0a7c5945"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structd3_1_1set.html">d3::set</a>&lt; int &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#affb7a403f294a57ca86da7ec0a7c5945">range_t</a></td></tr>
<tr class="separator:affb7a403f294a57ca86da7ec0a7c5945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f22edd7bc4b7cb9d34586075667e669"><td class="memItemLeft" align="right" valign="top">typedef range_t::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#a0f22edd7bc4b7cb9d34586075667e669">range_it</a></td></tr>
<tr class="separator:a0f22edd7bc4b7cb9d34586075667e669"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abea95e1c6d1d3c496bdfe72db17313c6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#abea95e1c6d1d3c496bdfe72db17313c6">GHom</a> (const <a class="el" href="class__GHom.html">_GHom</a> *_h)</td></tr>
<tr class="memdesc:abea95e1c6d1d3c496bdfe72db17313c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A uncontrolled constructor used in internals.  <a href="#abea95e1c6d1d3c496bdfe72db17313c6">More...</a><br/></td></tr>
<tr class="separator:abea95e1c6d1d3c496bdfe72db17313c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3229c2d620541eaf310c1e8ac8430324"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#a3229c2d620541eaf310c1e8ac8430324">GHom</a> (<a class="el" href="class__GHom.html">_GHom</a> *_h)</td></tr>
<tr class="memdesc:a3229c2d620541eaf310c1e8ac8430324"><td class="mdescLeft">&#160;</td><td class="mdescRight">THIS VERSION IS DELIBERATELY UNIMPLEMENTED OTHERWISE bad calls like <a class="el" href="classGShom.html" title="This class is the base class for Homomorphisms over SDD. ">GShom(new myHom())</a> would promote to const <a class="el" href="class__GShom.html" title="The concrete data class for Homomorphisms. ">_GShom</a> *_h and bypass unicity.  <a href="#a3229c2d620541eaf310c1e8ac8430324">More...</a><br/></td></tr>
<tr class="separator:a3229c2d620541eaf310c1e8ac8430324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37412107f59f9297138936dc0b91df5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#ae37412107f59f9297138936dc0b91df5">GHom</a> (const <a class="el" href="class__GHom.html">_GHom</a> &amp;_h)</td></tr>
<tr class="memdesc:ae37412107f59f9297138936dc0b91df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">build a <a class="el" href="classGHom.html" title="This class is the base class representing a homomorphism over DDD. ">GHom</a> from user provided homomorphisms such as <a class="el" href="classStrongHom.html" title="The abstract base class for user defined operations. ">StrongHom</a>.  <a href="#ae37412107f59f9297138936dc0b91df5">More...</a><br/></td></tr>
<tr class="separator:ae37412107f59f9297138936dc0b91df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f51453eb92ad99341f002d66ca4d64a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classGHom.html#affb7a403f294a57ca86da7ec0a7c5945">range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#a9f51453eb92ad99341f002d66ca4d64a">get_range</a> () const </td></tr>
<tr class="memdesc:a9f51453eb92ad99341f002d66ca4d64a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the range for this homomorphism, i.e. the dual of skip_variable.  <a href="#a9f51453eb92ad99341f002d66ca4d64a">More...</a><br/></td></tr>
<tr class="separator:a9f51453eb92ad99341f002d66ca4d64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8bf90af18a29f8369d00b74c09e194"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGHom.html">GHom</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#aaa8bf90af18a29f8369d00b74c09e194">invert</a> (const <a class="el" href="classGDDD.html">GDDD</a> &amp;pot) const </td></tr>
<tr class="memdesc:aaa8bf90af18a29f8369d00b74c09e194"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the predescessor homomorphism, using pot to determine variable domains  <a href="#aaa8bf90af18a29f8369d00b74c09e194">More...</a><br/></td></tr>
<tr class="separator:aaa8bf90af18a29f8369d00b74c09e194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef2fec2e826a694dddcb8040ef8ae65a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGDDD.html">GDDD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#aef2fec2e826a694dddcb8040ef8ae65a">has_image</a> (const <a class="el" href="classGDDD.html">GDDD</a> &amp;d) const </td></tr>
<tr class="memdesc:aef2fec2e826a694dddcb8040ef8ae65a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if and only if h(d) != <a class="el" href="classGSDD.html#afa7b1f8c6bdc93d34216a610665facd8" title="The non-accepting terminal. ">SDD::null</a>  <a href="#aef2fec2e826a694dddcb8040ef8ae65a">More...</a><br/></td></tr>
<tr class="separator:aef2fec2e826a694dddcb8040ef8ae65a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34cc5646112b5ac8ae79fc499e0a5850"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGHom.html">GHom</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#a34cc5646112b5ac8ae79fc499e0a5850">negate</a> () const </td></tr>
<tr class="memdesc:a34cc5646112b5ac8ae79fc499e0a5850"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a negation of a selector homomorphism h, such that h.negate() (d) = d - h(d)  <a href="#a34cc5646112b5ac8ae79fc499e0a5850">More...</a><br/></td></tr>
<tr class="separator:a34cc5646112b5ac8ae79fc499e0a5850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41745b72c666e9718ebf33c20d61f460"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGDDD.html">GDDD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#a41745b72c666e9718ebf33c20d61f460">operator()</a> (const <a class="el" href="classGDDD.html">GDDD</a> &amp;d) const </td></tr>
<tr class="memdesc:a41745b72c666e9718ebf33c20d61f460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation operator.  <a href="#a41745b72c666e9718ebf33c20d61f460">More...</a><br/></td></tr>
<tr class="separator:a41745b72c666e9718ebf33c20d61f460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf148bf7af0b8348f7a596d7ef425f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGDDD.html">GDDD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#aadf148bf7af0b8348f7a596d7ef425f2">eval</a> (const <a class="el" href="classGDDD.html">GDDD</a> &amp;d) const </td></tr>
<tr class="memdesc:aadf148bf7af0b8348f7a596d7ef425f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation function : users should use operator() instead of this.  <a href="#aadf148bf7af0b8348f7a596d7ef425f2">More...</a><br/></td></tr>
<tr class="separator:aadf148bf7af0b8348f7a596d7ef425f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba7b975d2330f2837e899cb24e71819"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#acba7b975d2330f2837e899cb24e71819">skip_variable</a> (int var) const </td></tr>
<tr class="separator:acba7b975d2330f2837e899cb24e71819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7b22844fd8aea4fd559077db4d323d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGHom.html">GHom</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#a1c7b22844fd8aea4fd559077db4d323d">compose</a> (const <a class="el" href="classGHom.html">GHom</a> &amp;r) const </td></tr>
<tr class="separator:a1c7b22844fd8aea4fd559077db4d323d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb92252687a77f94a59dc468e7f2af0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#abcb92252687a77f94a59dc468e7f2af0">refCounter</a> () const </td></tr>
<tr class="memdesc:abcb92252687a77f94a59dc468e7f2af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor to visualize the reference count of the concret instance.  <a href="#abcb92252687a77f94a59dc468e7f2af0">More...</a><br/></td></tr>
<tr class="separator:abcb92252687a77f94a59dc468e7f2af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Public Constructors</div></td></tr>
<tr class="memitem:aaa7c39610e9d16460a40edf47c8d679b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#aaa7c39610e9d16460a40edf47c8d679b">GHom</a> ()</td></tr>
<tr class="memdesc:aaa7c39610e9d16460a40edf47c8d679b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default public constructor.  <a href="#aaa7c39610e9d16460a40edf47c8d679b">More...</a><br/></td></tr>
<tr class="separator:aaa7c39610e9d16460a40edf47c8d679b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39794f56b351c24753a1213698a3c7d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#a39794f56b351c24753a1213698a3c7d9">GHom</a> (const <a class="el" href="classMLHom.html">MLHom</a> &amp;)</td></tr>
<tr class="memdesc:a39794f56b351c24753a1213698a3c7d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulate an <a class="el" href="classMLHom.html">MLHom</a>, by setting a stop level for the upstream homomorphisms.  <a href="#a39794f56b351c24753a1213698a3c7d9">More...</a><br/></td></tr>
<tr class="separator:a39794f56b351c24753a1213698a3c7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb6c6fd0263b0d3ef896295d8df2d9d2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#adb6c6fd0263b0d3ef896295d8df2d9d2">GHom</a> (const <a class="el" href="classGDDD.html">GDDD</a> &amp;d)</td></tr>
<tr class="memdesc:adb6c6fd0263b0d3ef896295d8df2d9d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a constant <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams. ">DDD</a> homomorphism.  <a href="#adb6c6fd0263b0d3ef896295d8df2d9d2">More...</a><br/></td></tr>
<tr class="separator:adb6c6fd0263b0d3ef896295d8df2d9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04cf459f18217b62b59d3a99676f15d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#a04cf459f18217b62b59d3a99676f15d9">GHom</a> (int var, int val, const <a class="el" href="classGHom.html">GHom</a> &amp;h=<a class="el" href="classGHom.html#af17f84f00ffadd24e2f2894e0c8a2207">GHom::id</a>)</td></tr>
<tr class="memdesc:a04cf459f18217b62b59d3a99676f15d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create variable/value pair and left concatenate to a homomorphism.  <a href="#a04cf459f18217b62b59d3a99676f15d9">More...</a><br/></td></tr>
<tr class="separator:a04cf459f18217b62b59d3a99676f15d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Comparisons for hash and map storage</div></td></tr>
<tr class="memitem:aa7db8175b2ed7ca7ff42ed5d2bb51f60"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#aa7db8175b2ed7ca7ff42ed5d2bb51f60">operator==</a> (const <a class="el" href="classGHom.html">GHom</a> &amp;h) const </td></tr>
<tr class="memdesc:aa7db8175b2ed7ca7ff42ed5d2bb51f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison between Homomorphisms.  <a href="#aa7db8175b2ed7ca7ff42ed5d2bb51f60">More...</a><br/></td></tr>
<tr class="separator:aa7db8175b2ed7ca7ff42ed5d2bb51f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cdb66c862560660eff92a569eb55015"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#a8cdb66c862560660eff92a569eb55015">operator!=</a> (const <a class="el" href="classGHom.html">GHom</a> &amp;h) const </td></tr>
<tr class="memdesc:a8cdb66c862560660eff92a569eb55015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison between Homomorphisms.  <a href="#a8cdb66c862560660eff92a569eb55015">More...</a><br/></td></tr>
<tr class="separator:a8cdb66c862560660eff92a569eb55015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6be6ccb7775aeb9072c2c80ff7a7476"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#af6be6ccb7775aeb9072c2c80ff7a7476">operator&lt;</a> (const <a class="el" href="classGHom.html">GHom</a> &amp;h) const </td></tr>
<tr class="memdesc:af6be6ccb7775aeb9072c2c80ff7a7476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total ordering function between <a class="el" href="classHom.html" title="This is the user interface class to manipulate homomorphisms. ">Hom</a>.  <a href="#af6be6ccb7775aeb9072c2c80ff7a7476">More...</a><br/></td></tr>
<tr class="separator:af6be6ccb7775aeb9072c2c80ff7a7476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe91da1f27fdc2b628969cf16215e7bb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#abe91da1f27fdc2b628969cf16215e7bb">is_selector</a> () const </td></tr>
<tr class="memdesc:abe91da1f27fdc2b628969cf16215e7bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This predicate is true if the homomorphism global behavior is only to prune some paths.  <a href="#abe91da1f27fdc2b628969cf16215e7bb">More...</a><br/></td></tr>
<tr class="separator:abe91da1f27fdc2b628969cf16215e7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7266d79542766306959021e910cfae9f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGHom.html">GHom</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#a7266d79542766306959021e910cfae9f">add</a> (const <a class="el" href="structd3_1_1set.html">d3::set</a>&lt; <a class="el" href="classGHom.html">GHom</a> &gt;::type &amp;set)</td></tr>
<tr class="memdesc:a7266d79542766306959021e910cfae9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constructor for a union of several homomorphisms.  <a href="#a7266d79542766306959021e910cfae9f">More...</a><br/></td></tr>
<tr class="separator:a7266d79542766306959021e910cfae9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12ff552ae92a1a29c608e828ee1a4e7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGHom.html">GHom</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#af12ff552ae92a1a29c608e828ee1a4e7">ccompose</a> (const <a class="el" href="structd3_1_1set.html">d3::set</a>&lt; <a class="el" href="classGHom.html">GHom</a> &gt;::type &amp;set)</td></tr>
<tr class="memdesc:af12ff552ae92a1a29c608e828ee1a4e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constructor for a commutative composition of several homomorphisms.  <a href="#af12ff552ae92a1a29c608e828ee1a4e7">More...</a><br/></td></tr>
<tr class="separator:af12ff552ae92a1a29c608e828ee1a4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:af17f84f00ffadd24e2f2894e0c8a2207"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classGHom.html">GHom</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#af17f84f00ffadd24e2f2894e0c8a2207">id</a></td></tr>
<tr class="memdesc:af17f84f00ffadd24e2f2894e0c8a2207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementary homomorphism <a class="el" href="classIdentity.html">Identity</a>, defined as a constant.  <a href="#af17f84f00ffadd24e2f2894e0c8a2207">More...</a><br/></td></tr>
<tr class="separator:af17f84f00ffadd24e2f2894e0c8a2207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66502d762eb0bbc63dc118d7c7ba8537"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classGHom.html#affb7a403f294a57ca86da7ec0a7c5945">range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#a66502d762eb0bbc63dc118d7c7ba8537">full_range</a> = <a class="el" href="classGHom.html#affb7a403f294a57ca86da7ec0a7c5945">GHom::range_t</a>()</td></tr>
<tr class="memdesc:a66502d762eb0bbc63dc118d7c7ba8537"><td class="mdescLeft">&#160;</td><td class="mdescRight">The full_range : that targets everyone.  <a href="#a66502d762eb0bbc63dc118d7c7ba8537">More...</a><br/></td></tr>
<tr class="separator:a66502d762eb0bbc63dc118d7c7ba8537"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aecc8fb38ce35a0e8e78e0c0a2838ec2e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class__GHom.html">_GHom</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#aecc8fb38ce35a0e8e78e0c0a2838ec2e">concret</a></td></tr>
<tr class="memdesc:aecc8fb38ce35a0e8e78e0c0a2838ec2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The real implementation class.  <a href="#aecc8fb38ce35a0e8e78e0c0a2838ec2e">More...</a><br/></td></tr>
<tr class="separator:aecc8fb38ce35a0e8e78e0c0a2838ec2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ae4d28fb19857b759f903d4c41a9f0368"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#ae4d28fb19857b759f903d4c41a9f0368">Hom</a></td></tr>
<tr class="memdesc:ae4d28fb19857b759f903d4c41a9f0368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open access to <a class="el" href="classHom.html" title="This is the user interface class to manipulate homomorphisms. ">Hom</a> derived class.  <a href="#ae4d28fb19857b759f903d4c41a9f0368">More...</a><br/></td></tr>
<tr class="separator:ae4d28fb19857b759f903d4c41a9f0368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc44ade8b94f1ac5ede572ec1768465d"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#abc44ade8b94f1ac5ede572ec1768465d">_GHom</a></td></tr>
<tr class="memdesc:abc44ade8b94f1ac5ede572ec1768465d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open access to <a class="el" href="class__GHom.html" title="The concrete data class for Homomorphisms. ">_GHom</a> based homomophisms.  <a href="#abc44ade8b94f1ac5ede572ec1768465d">More...</a><br/></td></tr>
<tr class="separator:abc44ade8b94f1ac5ede572ec1768465d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfec5f168403955220be37f8ecc27ed8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGHom.html">GHom</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#abfec5f168403955220be37f8ecc27ed8">fixpoint</a> (const <a class="el" href="classGHom.html">GHom</a> &amp;, bool)</td></tr>
<tr class="memdesc:abfec5f168403955220be37f8ecc27ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This operator applies its argument to a node until a fixpoint is reached.  <a href="#abfec5f168403955220be37f8ecc27ed8">More...</a><br/></td></tr>
<tr class="separator:abfec5f168403955220be37f8ecc27ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb5ad558aace66b30a6926df2ad5d4f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGHom.html">GHom</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#adb5ad558aace66b30a6926df2ad5d4f9">monotonic</a> (const <a class="el" href="structd3_1_1set.html">d3::set</a>&lt; <a class="el" href="classGHom.html">GHom</a> &gt;::type &amp;set)</td></tr>
<tr class="memdesc:adb5ad558aace66b30a6926df2ad5d4f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This operator applies its arguments to a node until a fixpoint is reached.  <a href="#adb5ad558aace66b30a6926df2ad5d4f9">More...</a><br/></td></tr>
<tr class="separator:adb5ad558aace66b30a6926df2ad5d4f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02a172cd3cc33885b9dddb06a1fbfc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGHom.html">GHom</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#ad02a172cd3cc33885b9dddb06a1fbfc9">operator+</a> (const <a class="el" href="classGHom.html">GHom</a> &amp;, const <a class="el" href="classGHom.html">GHom</a> &amp;)</td></tr>
<tr class="memdesc:ad02a172cd3cc33885b9dddb06a1fbfc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This operator creates an operation that is the union of two operations.  <a href="#ad02a172cd3cc33885b9dddb06a1fbfc9">More...</a><br/></td></tr>
<tr class="separator:ad02a172cd3cc33885b9dddb06a1fbfc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c897e330df47a425c599f665cf2ffd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGHom.html">GHom</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#ab4c897e330df47a425c599f665cf2ffd">operator&amp;</a> (const <a class="el" href="classGHom.html">GHom</a> &amp;, const <a class="el" href="classGHom.html">GHom</a> &amp;)</td></tr>
<tr class="memdesc:ab4c897e330df47a425c599f665cf2ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This operator creates an operation that is the composition of two operations.  <a href="#ab4c897e330df47a425c599f665cf2ffd">More...</a><br/></td></tr>
<tr class="separator:ab4c897e330df47a425c599f665cf2ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec978e9de787633d746c1616cf6942c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGHom.html">GHom</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#abec978e9de787633d746c1616cf6942c">operator*</a> (const <a class="el" href="classGDDD.html">GDDD</a> &amp;, const <a class="el" href="classGHom.html">GHom</a> &amp;)</td></tr>
<tr class="memdesc:abec978e9de787633d746c1616cf6942c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This operator creates an operation that is the intersection of an operation and a constant <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams. ">DDD</a>.  <a href="#abec978e9de787633d746c1616cf6942c">More...</a><br/></td></tr>
<tr class="separator:abec978e9de787633d746c1616cf6942c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be385b3eedf23b7ba6473cf866aa3a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGHom.html">GHom</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#a1be385b3eedf23b7ba6473cf866aa3a6">operator*</a> (const <a class="el" href="classGHom.html">GHom</a> &amp;, const <a class="el" href="classGDDD.html">GDDD</a> &amp;)</td></tr>
<tr class="memdesc:a1be385b3eedf23b7ba6473cf866aa3a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This operator creates an operation that is the intersection of an operation and a constant <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams. ">DDD</a>.  <a href="#a1be385b3eedf23b7ba6473cf866aa3a6">More...</a><br/></td></tr>
<tr class="separator:a1be385b3eedf23b7ba6473cf866aa3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f83443dc2ba2ccaa68898193cdf98a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGHom.html">GHom</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#a8f83443dc2ba2ccaa68898193cdf98a2">operator^</a> (const <a class="el" href="classGDDD.html">GDDD</a> &amp;, const <a class="el" href="classGHom.html">GHom</a> &amp;)</td></tr>
<tr class="memdesc:a8f83443dc2ba2ccaa68898193cdf98a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the left concatenantion operator, that adds a constant <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams. ">DDD</a> above the operation.  <a href="#a8f83443dc2ba2ccaa68898193cdf98a2">More...</a><br/></td></tr>
<tr class="separator:a8f83443dc2ba2ccaa68898193cdf98a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ce94c20f05403c297ff9591ea18919"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGHom.html">GHom</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#ab8ce94c20f05403c297ff9591ea18919">operator^</a> (const <a class="el" href="classGHom.html">GHom</a> &amp;, const <a class="el" href="classGDDD.html">GDDD</a> &amp;)</td></tr>
<tr class="memdesc:ab8ce94c20f05403c297ff9591ea18919"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the right concatenantion operator, that adds a constant <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams. ">DDD</a> below the operation.  <a href="#ab8ce94c20f05403c297ff9591ea18919">More...</a><br/></td></tr>
<tr class="separator:ab8ce94c20f05403c297ff9591ea18919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64e9a1d83601035b2bafeb53e50989b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGHom.html">GHom</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#ab64e9a1d83601035b2bafeb53e50989b">operator-</a> (const <a class="el" href="classGHom.html">GHom</a> &amp;, const <a class="el" href="classGDDD.html">GDDD</a> &amp;)</td></tr>
<tr class="memdesc:ab64e9a1d83601035b2bafeb53e50989b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a set difference constructor, only available for (hom - ddd), not hom - hom as that might not preserve linearity.  <a href="#ab64e9a1d83601035b2bafeb53e50989b">More...</a><br/></td></tr>
<tr class="separator:ab64e9a1d83601035b2bafeb53e50989b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6ed2147a63e065563824e6fb647cee"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#a4c6ed2147a63e065563824e6fb647cee">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classGHom.html">GHom</a> &amp;h)</td></tr>
<tr class="separator:a4c6ed2147a63e065563824e6fb647cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Memory Management</h2></td></tr>
<tr class="memitem:aa56524036de8c91ea495e51a715599b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#aa56524036de8c91ea495e51a715599b5">mark</a> () const </td></tr>
<tr class="memdesc:aa56524036de8c91ea495e51a715599b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">For garbage collection internals. Marks a <a class="el" href="classGHom.html" title="This class is the base class representing a homomorphism over DDD. ">GHom</a> as in use in garbage collection phase.  <a href="#aa56524036de8c91ea495e51a715599b5">More...</a><br/></td></tr>
<tr class="separator:aa56524036de8c91ea495e51a715599b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f795ee348657e5fe7a83158bf886919"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#a2f795ee348657e5fe7a83158bf886919">hash</a> () const </td></tr>
<tr class="memdesc:a2f795ee348657e5fe7a83158bf886919"><td class="mdescLeft">&#160;</td><td class="mdescRight">For storage in a hash table.  <a href="#a2f795ee348657e5fe7a83158bf886919">More...</a><br/></td></tr>
<tr class="separator:a2f795ee348657e5fe7a83158bf886919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85cadfee3758f316757eb2e641b3e608"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#a85cadfee3758f316757eb2e641b3e608">statistics</a> ()</td></tr>
<tr class="memdesc:a85cadfee3758f316757eb2e641b3e608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns unicity table current size. Gives the number of different <a class="el" href="class__GHom.html" title="The concrete data class for Homomorphisms. ">_GHom</a> created and not yet destroyed.  <a href="#a85cadfee3758f316757eb2e641b3e608">More...</a><br/></td></tr>
<tr class="separator:a85cadfee3758f316757eb2e641b3e608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ea821dfa8f18942aea43f46da617af"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#a74ea821dfa8f18942aea43f46da617af">pstats</a> (bool reinit=true)</td></tr>
<tr class="memdesc:a74ea821dfa8f18942aea43f46da617af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints some statistics to std::cout.  <a href="#a74ea821dfa8f18942aea43f46da617af">More...</a><br/></td></tr>
<tr class="separator:a74ea821dfa8f18942aea43f46da617af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf18e5fe9fd3384e1c676b6e4f86a89"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#a7bf18e5fe9fd3384e1c676b6e4f86a89">garbage</a> ()</td></tr>
<tr class="memdesc:a7bf18e5fe9fd3384e1c676b6e4f86a89"><td class="mdescLeft">&#160;</td><td class="mdescRight">For garbage collection.  <a href="#a7bf18e5fe9fd3384e1c676b6e4f86a89">More...</a><br/></td></tr>
<tr class="separator:a7bf18e5fe9fd3384e1c676b6e4f86a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class is the base class representing a homomorphism over <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams. ">DDD</a>. </p>
<p>A <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams. ">DDD</a> homomorphism is a linear application that respects the better-defined relation (see ICATPN'2002 paper by Couvreur et al.). It comes with composition &amp;, union +, and intersection * operators to construct complex operations from two homomorphisms. It also comes with the <a class="el" href="classGHom.html#abfec5f168403955220be37f8ecc27ed8" title="This operator applies its argument to a node until a fixpoint is reached. ">fixpoint()</a> unary operator, that allows to implement saturation (see FORTE'05 paper by Couvreur &amp; Thierry-Mieg) This class does not implement reference counting : <a class="el" href="classGHom.html" title="This class is the base class representing a homomorphism over DDD. ">GHom</a> are destroyed on MemoryManager::Garbage unless they are also referenced as <a class="el" href="classHom.html" title="This is the user interface class to manipulate homomorphisms. ">Hom</a>. Note that this class is in fact a kind of smart pointer : operations are delegated on "concret" the true implementation class (of private hidden type <a class="el" href="class__GHom.html" title="The concrete data class for Homomorphisms. ">_GHom</a>) that contains the data and has a single memory occurrence thanks to the unicity table. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="aa6dc06d4106df676eeffdd02a24928ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classGDDD.html">GDDD</a> <a class="el" href="classGHom.html#aa6dc06d4106df676eeffdd02a24928ea">GHom::NodeType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0f22edd7bc4b7cb9d34586075667e669"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef range_t::const_iterator <a class="el" href="classGHom.html#a0f22edd7bc4b7cb9d34586075667e669">GHom::range_it</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="affb7a403f294a57ca86da7ec0a7c5945"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structd3_1_1set.html">d3::set</a>&lt;int&gt;::type <a class="el" href="classGHom.html#affb7a403f294a57ca86da7ec0a7c5945">GHom::range_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="abea95e1c6d1d3c496bdfe72db17313c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GHom::GHom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class__GHom.html">_GHom</a> *&#160;</td>
          <td class="paramname"><em>_h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A uncontrolled constructor used in internals. </p>
<p>Made public for calls like return <a class="el" href="classGHom.html" title="This class is the base class representing a homomorphism over DDD. ">GHom(this)</a> in <a class="el" href="classStrongHom.html#aabfad0dce33e7ec55bf4d87f27e79907" title="Evaluation over an arbitrary arc of a SDD. ">StrongHom::phi</a> definitions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_h</td><td>The pointer provided should point into the unicity table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3229c2d620541eaf310c1e8ac8430324"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GHom::GHom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class__GHom.html">_GHom</a> *&#160;</td>
          <td class="paramname"><em>_h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>THIS VERSION IS DELIBERATELY UNIMPLEMENTED OTHERWISE bad calls like <a class="el" href="classGShom.html" title="This class is the base class for Homomorphisms over SDD. ">GShom(new myHom())</a> would promote to const <a class="el" href="class__GShom.html" title="The concrete data class for Homomorphisms. ">_GShom</a> *_h and bypass unicity. </p>
<p>User code prior to 20/05/08 would use this in the form : return new myHom(xx); This is now illegal as we take up memory allocation now, so the user should stack alloc and pass a reference as in <a class="el" href="classGShom.html" title="This class is the base class for Homomorphisms over SDD. ">GShom(const _GShom &amp;_h)</a>. Exceptionally, for efficiency, return this; in a phi user function is permitted hence public visibility of above <a class="el" href="classGShom.html" title="This class is the base class for Homomorphisms over SDD. ">GShom(const _GShom *_h)</a>; This signature is here to ensure link errors in old user code. </p>

</div>
</div>
<a class="anchor" id="ae37412107f59f9297138936dc0b91df5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GHom::GHom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class__GHom.html">_GHom</a> &amp;&#160;</td>
          <td class="paramname"><em>_h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>build a <a class="el" href="classGHom.html" title="This class is the base class representing a homomorphism over DDD. ">GHom</a> from user provided homomorphisms such as <a class="el" href="classStrongHom.html" title="The abstract base class for user defined operations. ">StrongHom</a>. </p>
<p>This call ensures canonization of h </p>

</div>
</div>
<a class="anchor" id="aaa7c39610e9d16460a40edf47c8d679b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GHom::GHom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default public constructor. </p>
<p>Builds <a class="el" href="classIdentity.html">Identity</a> homomorphism : forall d in <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams. ">DDD</a>, id(d) = d </p>

<p>Referenced by <a class="el" href="classGHom.html#a7266d79542766306959021e910cfae9f">add()</a>.</p>

</div>
</div>
<a class="anchor" id="a39794f56b351c24753a1213698a3c7d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GHom::GHom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMLHom.html">MLHom</a> &amp;&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encapsulate an <a class="el" href="classMLHom.html">MLHom</a>, by setting a stop level for the upstream homomorphisms. </p>

</div>
</div>
<a class="anchor" id="adb6c6fd0263b0d3ef896295d8df2d9d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GHom::GHom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGDDD.html">GDDD</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a constant <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams. ">DDD</a> homomorphism. </p>
<p>These are the basic building bricks of more complex operations. h(d1) (d2) = d1 Where d1 is a <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams. ">DDD</a>, h(d1) a constant homomorphism and d2 an arbitrary <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams. ">DDD</a>. </p>

</div>
</div>
<a class="anchor" id="a04cf459f18217b62b59d3a99676f15d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GHom::GHom </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGHom.html">GHom</a> &amp;&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classGHom.html#af17f84f00ffadd24e2f2894e0c8a2207">GHom::id</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create variable/value pair and left concatenate to a homomorphism. </p>
<p>h(var,val,g) (d) = <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams. ">DDD(var,val)</a> ^ g(d). In other words : var &ndash; val -&gt; g </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>the variable index </td></tr>
    <tr><td class="paramname">val</td><td>the value associated to the variable </td></tr>
    <tr><td class="paramname">h</td><td>the homomorphism to apply on successor node. Default is identity, so is equivalent to a left concatenation of a <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams. ">DDD(var,val)</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7266d79542766306959021e910cfae9f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGHom.html">GHom</a> GHom::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structd3_1_1set.html">d3::set</a>&lt; <a class="el" href="classGHom.html">GHom</a> &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A constructor for a union of several homomorphisms. </p>
<p>Note that for canonisation and optimization reasons, union is an n-ary and commutative composition operator. Use of this constructor may be slightly more efficient than using operator+ multiple times. H({h1,h2, ..hn}) (d) = sum_i h_i (d). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>the set of homomorphisms to put in the union. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>std::set not very efficient for storage, replace by a sorted vector ? </dd></dl>

<p>References <a class="el" href="Hom_8cpp.html#a6631bdd37025b6ab2a5654d0109d99d1">canonical</a>, <a class="el" href="classGHom.html#aaa7c39610e9d16460a40edf47c8d679b">GHom()</a>, and <a class="el" href="classGDDD.html#aa8754c2682b769a8e134e11025d0ef17">GDDD::null</a>.</p>

<p>Referenced by <a class="el" href="Hom_8h.html#a33e03b90df48e932ce2ca123ee80eca2">fixpoint()</a>, <a class="el" href="class__setVarConst.html#adeb19530ffd33beeca798674c63c3d12">_setVarConst::invert()</a>, <a class="el" href="classAdd.html#ac2377b56a5a719921002aec940f4592d">Add::invert()</a>, <a class="el" href="classAnd.html#ab02e4da10e4bd9b38d34f772ba5ddbf9">And::negate()</a>, <a class="el" href="Hom_8h.html#ad02a172cd3cc33885b9dddb06a1fbfc9">operator+()</a>, and <a class="el" href="classAdd.html#ae81a1837c7c101e7838a2f4371bb1b31">Add::skip_variable()</a>.</p>

</div>
</div>
<a class="anchor" id="af12ff552ae92a1a29c608e828ee1a4e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGHom.html">GHom</a> GHom::ccompose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structd3_1_1set.html">d3::set</a>&lt; <a class="el" href="classGHom.html">GHom</a> &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A constructor for a commutative composition of several homomorphisms. </p>
<p>It's up to user to ensure pairwise commutatitivity off all arguments in the set </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>the set of homomorphisms to put in the composition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>std::set not very efficient for storage, replace by a sorted vector ? </dd></dl>

<p>References <a class="el" href="Hom_8cpp.html#a6631bdd37025b6ab2a5654d0109d99d1">canonical</a>, and <a class="el" href="classGHom.html#af17f84f00ffadd24e2f2894e0c8a2207">id</a>.</p>

<p>Referenced by <a class="el" href="classAdd.html#ac6aabdd129249f09a3becf666a2bf2d1">Add::negate()</a>.</p>

</div>
</div>
<a class="anchor" id="a1c7b22844fd8aea4fd559077db4d323d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGHom.html">GHom</a> GHom::compose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGHom.html">GHom</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="class__GHom.html#a4e4d93ed9bec4d8893a3bfeff8f0d24f">_GHom::compose()</a>, and <a class="el" href="classGHom.html#aecc8fb38ce35a0e8e78e0c0a2838ec2e">concret</a>.</p>

<p>Referenced by <a class="el" href="classnsMLHom_1_1ConstantUp.html#a7a90ecd1bd757989120f823e77f935f5">nsMLHom::ConstantUp::eval()</a>, and <a class="el" href="Hom_8h.html#ab4c897e330df47a425c599f665cf2ffd">operator&amp;()</a>.</p>

</div>
</div>
<a class="anchor" id="aadf148bf7af0b8348f7a596d7ef425f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGDDD.html">GDDD</a> GHom::eval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGDDD.html">GDDD</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluation function : users should use operator() instead of this. </p>
<p>This evaluation function does not use the cache, it is called in case of cache miss in the call to operator(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>the argument <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams. ">DDD</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>h(d) </dd></dl>

<p>References <a class="el" href="classGHom.html#aecc8fb38ce35a0e8e78e0c0a2838ec2e">concret</a>, and <a class="el" href="class__GHom.html#aa50ec89149a2416125850f1690cb4d31">_GHom::eval_skip()</a>.</p>

<p>Referenced by <a class="el" href="class__DED__Hom.html#a6aa0126b5638073a319d101381a435e1">_DED_Hom::eval()</a>.</p>

</div>
</div>
<a class="anchor" id="a7bf18e5fe9fd3384e1c676b6e4f86a89"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GHom::garbage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For garbage collection. </p>
<p><em>WARNING</em> Do not use this function directly !! Use <a class="el" href="classMemoryManager.html#a2e3ca8e74e2b79a6d32fc40f192ddef9" title="Garbage collection function. ">MemoryManager::garbage()</a> to ensure proper reference counting and cache cleanup. Garbage collection algorithm is a simple two phase mark and sweep : in phase mark, all nodes with positive reference counts are marked, as well as their descendants, recursively. In phase sweep, all nodes which are unmarked are destroyed. This avoids maintaining reference counts during operation : only external references made through the <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams. ">DDD</a> class are counted, and no recursive reference counting is needed. </p>

<p>References <a class="el" href="classCache.html#aa090a7ccac0b1633d1038ce501c503bb">Cache&lt; FuncType, ParamType, ResType, EvalFunc &gt;::clear()</a>, <a class="el" href="class__GHom.html#aeba0225978ef0b1f9d675ae89bbc22ff">_GHom::marking</a>, and <a class="el" href="classUniqueTable.html#a4bb608adea0323a1c994d0075e574379">UniqueTable&lt; T &gt;::table</a>.</p>

<p>Referenced by <a class="el" href="classMemoryManager.html#a2e3ca8e74e2b79a6d32fc40f192ddef9">MemoryManager::garbage()</a>.</p>

</div>
</div>
<a class="anchor" id="a9f51453eb92ad99341f002d66ca4d64a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classGHom.html#affb7a403f294a57ca86da7ec0a7c5945">GHom::range_t</a> GHom::get_range </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the range for this homomorphism, i.e. the dual of skip_variable. </p>

<p>References <a class="el" href="classGHom.html#aecc8fb38ce35a0e8e78e0c0a2838ec2e">concret</a>, and <a class="el" href="class__GHom.html#a18280ac9f5c3ed99024092277e661397">_GHom::get_range()</a>.</p>

<p>Referenced by <a class="el" href="Hom_8h.html#ac9c0db67e53e0b2055fb42973ce6bb34">commutative()</a>, <a class="el" href="Hom_8h.html#a33e03b90df48e932ce2ca123ee80eca2">fixpoint()</a>, <a class="el" href="classNotCond.html#a110522a83719ce4cd12108fd731ede37">NotCond::get_range()</a>, <a class="el" href="classCompose.html#a11bf322e6d04b3644d43f44290e32e54">Compose::get_range()</a>, <a class="el" href="classFixpoint.html#aa478c662053158c5a306406f587ba70c">Fixpoint::get_range()</a>, and <a class="el" href="Hom_8cpp.html#a8da3f8972b1120cf22ebf61d8196e936">notInRange()</a>.</p>

</div>
</div>
<a class="anchor" id="aef2fec2e826a694dddcb8040ef8ae65a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGDDD.html">GDDD</a> GHom::has_image </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGDDD.html">GDDD</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if and only if h(d) != <a class="el" href="classGSDD.html#afa7b1f8c6bdc93d34216a610665facd8" title="The non-accepting terminal. ">SDD::null</a> </p>

<p>References <a class="el" href="classCache.html#a35cdc08128616d368035df29bed4a01a">Cache&lt; FuncType, ParamType, ResType, EvalFunc &gt;::insert()</a>, and <a class="el" href="classGDDD.html#aa8754c2682b769a8e134e11025d0ef17">GDDD::null</a>.</p>

<p>Referenced by <a class="el" href="classInter.html#a46ff19f4d6cce1ef26f2825e1195d857">Inter::has_image()</a>, <a class="el" href="classNotCond.html#a50281b78f705d2df58edb6851afcf5eb">NotCond::has_image()</a>, <a class="el" href="classsns_1_1LocalApply.html#a15f32418d207c13610b0ddce6c5eaf7d">sns::LocalApply::has_image()</a>, <a class="el" href="classAdd.html#aac85110d7081ee4265da3badf7da96a0">Add::has_image()</a>, <a class="el" href="classLeftConcat.html#a897b2bdf79640e35eb4a6f7acaab87f4">LeftConcat::has_image()</a>, <a class="el" href="classRightConcat.html#abb029c6d113edd5ce0e8a61895a5a3b0">RightConcat::has_image()</a>, <a class="el" href="classFixpoint.html#ae31be0bcc8612526426636ef952123e0">Fixpoint::has_image()</a>, and <a class="el" href="class__GHom.html#a1385269a8a9adb725d5bcb2a144685b1">_GHom::has_image_skip()</a>.</p>

</div>
</div>
<a class="anchor" id="a2f795ee348657e5fe7a83158bf886919"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t GHom::hash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For storage in a hash table. </p>

<p>References <a class="el" href="classGHom.html#aecc8fb38ce35a0e8e78e0c0a2838ec2e">concret</a>, and <a class="el" href="group__hash__funcs.html#gaa1df7f93d9288358c1b6d6892cc6ca38">ddd::knuth32_hash()</a>.</p>

<p>Referenced by <a class="el" href="classnsMLHom_1_1GHomAdapter.html#aeff177a8f2fbf1c8715cae6fab943bcb">nsMLHom::GHomAdapter::hash()</a>, <a class="el" href="classnsMLHom_1_1ConstantUp.html#af2e11b393b921734c59f0737b9ace856">nsMLHom::ConstantUp::hash()</a>, <a class="el" href="classMult.html#a5508787d4845a536e70d9a9d6d695077">Mult::hash()</a>, <a class="el" href="classInter.html#ab0cefdeea72d390c47675db9db17250e">Inter::hash()</a>, <a class="el" href="classNotCond.html#a76485588a872057bc037f26942ef15d4">NotCond::hash()</a>, <a class="el" href="class__DED__Hom.html#ac4c3f0cce13408f52912a738c4407347">_DED_Hom::hash()</a>, <a class="el" href="classsns_1_1LocalApply.html#a4312010e9f5b386c02626558bfd67950">sns::LocalApply::hash()</a>, <a class="el" href="classCompose.html#a6d87ccfedaa5b41b871149954daf31f0">Compose::hash()</a>, <a class="el" href="classLeftConcat.html#a215c3bc8e73db446db6e3d2eea18aa84">LeftConcat::hash()</a>, <a class="el" href="classRightConcat.html#aca8cc58221b75b8c280a6bec62efc164">RightConcat::hash()</a>, <a class="el" href="classMinus.html#a4e0374dc547ed4f5bc7097a490c22783">Minus::hash()</a>, and <a class="el" href="classFixpoint.html#a6ed8bc0adc8c8d14384ff08554b2c9e7">Fixpoint::hash()</a>.</p>

</div>
</div>
<a class="anchor" id="aaa8bf90af18a29f8369d00b74c09e194"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGHom.html">GHom</a> GHom::invert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGDDD.html">GDDD</a> &amp;&#160;</td>
          <td class="paramname"><em>pot</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the predescessor homomorphism, using pot to determine variable domains </p>

<p>References <a class="el" href="classGHom.html#aecc8fb38ce35a0e8e78e0c0a2838ec2e">concret</a>, and <a class="el" href="class__GHom.html#a180685f2af4d3f1bfb68fd013fdb5a4f">_GHom::invert()</a>.</p>

<p>Referenced by <a class="el" href="classMult.html#a0af519e36a32b2b1eefb4684bf0d5cf4">Mult::invert()</a>, <a class="el" href="classInter.html#a61a4aa5416058438dbfa59c40704540f">Inter::invert()</a>, <a class="el" href="classsns_1_1LocalApply.html#ab25795d9e96972cc678e1ae44a174ec1">sns::LocalApply::invert()</a>, <a class="el" href="classCompose.html#a5c652502025d6d378ec043f1a502171f">Compose::invert()</a>, <a class="el" href="classMinus.html#a7f88750cd1634521629c0168882c6372">Minus::invert()</a>, and <a class="el" href="classFixpoint.html#a191c5d4cd8a10017c502a16b157504fe">Fixpoint::invert()</a>.</p>

</div>
</div>
<a class="anchor" id="abe91da1f27fdc2b628969cf16215e7bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GHom::is_selector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This predicate is true if the homomorphism global behavior is only to prune some paths. </p>

<p>References <a class="el" href="classGHom.html#aecc8fb38ce35a0e8e78e0c0a2838ec2e">concret</a>, and <a class="el" href="class__GHom.html#ac7da98695d2e4d446646f477fd40b42b">_GHom::is_selector()</a>.</p>

<p>Referenced by <a class="el" href="Hom_8h.html#ac9c0db67e53e0b2055fb42973ce6bb34">commutative()</a>, <a class="el" href="Hom_8h.html#a33e03b90df48e932ce2ca123ee80eca2">fixpoint()</a>, <a class="el" href="classMult.html#a3e36b3b949d7c2b21902f8f203fb5958">Mult::is_selector()</a>, <a class="el" href="classInter.html#aedada84a457c5186fe668039da12ded1">Inter::is_selector()</a>, <a class="el" href="classsns_1_1LocalApply.html#a037c3e9b0187d910cc754bf882d6b469">sns::LocalApply::is_selector()</a>, <a class="el" href="classCompose.html#a1e4313fa9039cbc7c26780850e6c451b">Compose::is_selector()</a>, <a class="el" href="classMinus.html#a2ba164483f50e88b533b8823e766ab9f">Minus::is_selector()</a>, <a class="el" href="classFixpoint.html#a2528a91e2d025aa9313890f125d7ef24">Fixpoint::is_selector()</a>, <a class="el" href="Hom_8h.html#a2e90a3967e662f4d95f2aeb8c1e02f65">ITE()</a>, <a class="el" href="Hom_8h.html#a0cd509228f69a72bd40c3323376936d0">operator!()</a>, and <a class="el" href="Hom_8h.html#a7977a93d214e8891de46de54e55ac606">operator*()</a>.</p>

</div>
</div>
<a class="anchor" id="aa56524036de8c91ea495e51a715599b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GHom::mark </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For garbage collection internals. Marks a <a class="el" href="classGHom.html" title="This class is the base class representing a homomorphism over DDD. ">GHom</a> as in use in garbage collection phase. </p>

<p>References <a class="el" href="classGHom.html#aecc8fb38ce35a0e8e78e0c0a2838ec2e">concret</a>, <a class="el" href="class__GHom.html#a7da0a07a204540390344a9c9f3b5b757">_GHom::mark()</a>, and <a class="el" href="class__GHom.html#aeba0225978ef0b1f9d675ae89bbc22ff">_GHom::marking</a>.</p>

<p>Referenced by <a class="el" href="classFixpoint.html#a3adbae871ff6a76a8b30c7fa78a43b51">Fixpoint::eval()</a>, <a class="el" href="classMemoryManager.html#a8558f88b4480cd64ccd7fe6a087fc38b">MemoryManager::mark()</a>, <a class="el" href="classMult.html#a5e97e53ae4c3025b8843f88577ac27f9">Mult::mark()</a>, <a class="el" href="classInter.html#a7db6ac98aea38fdc9b9f52f2766ed20c">Inter::mark()</a>, <a class="el" href="classNotCond.html#a52d0596d90b427a1489282b7ee725181">NotCond::mark()</a>, <a class="el" href="classsns_1_1LocalApply.html#a6bc1ae5d83e8a31217e36bc539e6726b">sns::LocalApply::mark()</a>, <a class="el" href="classCompose.html#aab97a8f23b062d1b4fe9f1921e6ca502">Compose::mark()</a>, <a class="el" href="classLeftConcat.html#a90d6ddfe6f081d0ec3489e57b5ced824">LeftConcat::mark()</a>, <a class="el" href="classRightConcat.html#a0be92f1367fdd23f45c94842c87df2e4">RightConcat::mark()</a>, <a class="el" href="classMinus.html#a421cfe4874da5ccb3345fbd239a96ee5">Minus::mark()</a>, and <a class="el" href="classFixpoint.html#a5daf617c933be8959f8abbeaec5fca8c">Fixpoint::mark()</a>.</p>

</div>
</div>
<a class="anchor" id="a34cc5646112b5ac8ae79fc499e0a5850"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGHom.html">GHom</a> GHom::negate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a negation of a selector homomorphism h, such that h.negate() (d) = d - h(d) </p>

<p>References <a class="el" href="classGHom.html#aecc8fb38ce35a0e8e78e0c0a2838ec2e">concret</a>, and <a class="el" href="class__GHom.html#acae47558bfc72e265638167e8c60e74b">_GHom::negate()</a>.</p>

<p>Referenced by <a class="el" href="classNotCond.html#a50281b78f705d2df58edb6851afcf5eb">NotCond::has_image()</a>, <a class="el" href="classInter.html#abbe67158b5d4937d89c797de2ae5c7ee">Inter::negate()</a>, and <a class="el" href="Hom_8h.html#a0cd509228f69a72bd40c3323376936d0">operator!()</a>.</p>

</div>
</div>
<a class="anchor" id="a8cdb66c862560660eff92a569eb55015"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="SHom_8h.html#ad5d208fc2ef94ac402f4a4572146d8f0">GHom::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGHom.html">GHom</a> &amp;&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison between Homomorphisms. </p>
<p>Note that comparison is based on "concret" address in unicity table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>the hom to compare to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the nodes are NOT equal. </dd></dl>

<p>References <a class="el" href="classGHom.html#aecc8fb38ce35a0e8e78e0c0a2838ec2e">concret</a>.</p>

</div>
</div>
<a class="anchor" id="a41745b72c666e9718ebf33c20d61f460"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGDDD.html">GDDD</a> GHom::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGDDD.html">GDDD</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluation operator. </p>
<p>Homomorphisms overload operator(), so they can be directly applied to <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams. ">DDD</a> nodes. Note that evaluation through this operator uses and updates a cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>the <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams. ">DDD</a> to apply this h to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>h(d), the result of applying this h to d. </dd></dl>

<p>References <a class="el" href="classGHom.html#aecc8fb38ce35a0e8e78e0c0a2838ec2e">concret</a>, <a class="el" href="class__GHom.html#ae416cdc5db5bd4d6ec2efe1ea7784ba2">_GHom::eval()</a>, <a class="el" href="class__GHom.html#aff0675e65defd25f8bd6cfb3d10e776b">_GHom::immediat</a>, <a class="el" href="classCache.html#a35cdc08128616d368035df29bed4a01a">Cache&lt; FuncType, ParamType, ResType, EvalFunc &gt;::insert()</a>, and <a class="el" href="classGDDD.html#aa8754c2682b769a8e134e11025d0ef17">GDDD::null</a>.</p>

</div>
</div>
<a class="anchor" id="af6be6ccb7775aeb9072c2c80ff7a7476"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GHom::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGHom.html">GHom</a> &amp;&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Total ordering function between <a class="el" href="classHom.html" title="This is the user interface class to manipulate homomorphisms. ">Hom</a>. </p>
<p>Note that comparison is based on chronological ordering of creation, and delegated to "concret". Unlike comparison on addresses in unicity table, this ensures reproductible results. This ordering is necessary for hash and map storage of <a class="el" href="classGHom.html" title="This class is the base class representing a homomorphism over DDD. ">GHom</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>the node to compare to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if argument h is greater than "this". </dd></dl>

<p>References <a class="el" href="classGHom.html#aecc8fb38ce35a0e8e78e0c0a2838ec2e">concret</a>.</p>

</div>
</div>
<a class="anchor" id="aa7db8175b2ed7ca7ff42ed5d2bb51f60"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GHom::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGHom.html">GHom</a> &amp;&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison between Homomorphisms. </p>
<p>Note that comparison is based on "concret" address in unicity table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>the hom to compare to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the nodes are equal. </dd></dl>

</div>
</div>
<a class="anchor" id="a74ea821dfa8f18942aea43f46da617af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GHom::pstats </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reinit</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints some statistics to std::cout. </p>
<p>Mostly used in debug and development phase. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000010">Todo:</a></b></dt><dd>allow output in other place than cout. Clean up output. </dd></dl>

<p>References <a class="el" href="classGHom.html#abc44ade8b94f1ac5ede572ec1768465d">_GHom</a>, and <a class="el" href="classUniqueTable.html#aa560bfa85682c28d0a7dabb9c5ed150a">UniqueTable&lt; T &gt;::size()</a>.</p>

<p>Referenced by <a class="el" href="classMemoryManager.html#a9e10543492e507784743d4f8fb074581">MemoryManager::pstats()</a>.</p>

</div>
</div>
<a class="anchor" id="abcb92252687a77f94a59dc468e7f2af0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GHom::refCounter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accessor to visualize the reference count of the concret instance. </p>
<p>See <a class="el" href="class__GHom.html#a8d389676b61e25c080e010bccbaf1f71" title="For garbage collection. ">_GHom::refCounter</a> for details. </p>

<p>References <a class="el" href="classGHom.html#aecc8fb38ce35a0e8e78e0c0a2838ec2e">concret</a>, and <a class="el" href="class__GHom.html#a8d389676b61e25c080e010bccbaf1f71">_GHom::refCounter</a>.</p>

</div>
</div>
<a class="anchor" id="acba7b975d2330f2837e899cb24e71819"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GHom::skip_variable </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="classGHom.html#aecc8fb38ce35a0e8e78e0c0a2838ec2e">concret</a>, and <a class="el" href="class__GHom.html#afd6b82107a7d28ed52d6dfd641b4178d">_GHom::skip_variable()</a>.</p>

<p>Referenced by <a class="el" href="classnsMLHom_1_1GHomAdapter.html#a2225933aadb43209bd1256b27f87416a">nsMLHom::GHomAdapter::skip_variable()</a>.</p>

</div>
</div>
<a class="anchor" id="a85cadfee3758f316757eb2e641b3e608"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int GHom::statistics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns unicity table current size. Gives the number of different <a class="el" href="class__GHom.html" title="The concrete data class for Homomorphisms. ">_GHom</a> created and not yet destroyed. </p>

<p>References <a class="el" href="classUniqueTable.html#aa560bfa85682c28d0a7dabb9c5ed150a">UniqueTable&lt; T &gt;::size()</a>.</p>

<p>Referenced by <a class="el" href="classStatistic.html#a8e933dbca3ceb8692ccad2e19c184a3d">Statistic::load()</a>, and <a class="el" href="classMemoryManager.html#a0514f2f1f691bcf3fcb25fbfbc0ecf46">MemoryManager::nbHom()</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="abc44ade8b94f1ac5ede572ec1768465d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class__GHom.html">_GHom</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open access to <a class="el" href="class__GHom.html" title="The concrete data class for Homomorphisms. ">_GHom</a> based homomophisms. </p>

<p>Referenced by <a class="el" href="classGHom.html#a74ea821dfa8f18942aea43f46da617af">pstats()</a>.</p>

</div>
</div>
<a class="anchor" id="abfec5f168403955220be37f8ecc27ed8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGHom.html">GHom</a> fixpoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGHom.html">GHom</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This operator applies its argument to a node until a fixpoint is reached. </p>
<p>Application consists in : while ( h(d) != d ) d = h(d); Where d is a <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams. ">DDD</a> and h a homomorphism.</p>
<p>This new unary operator is introduced to implement local saturation in transition relation evaluation. Proper use of fixpoint allows to effectively tackle the intermediate size problem of decision diagram based representations. Note that evaluation simply iterates until a fixpoint is reached, thus to cumulate new states with previously reached it should be combined with <a class="el" href="classGShom.html#ab283e77d8df01c595ad31652d3895090" title="Elementary SDD homomorphism identity. Applied to any SDD d, it returns d. ">GShom::id</a> as in</p>
<p>fixpoint ( h + <a class="el" href="classGShom.html#ab283e77d8df01c595ad31652d3895090" title="Elementary SDD homomorphism identity. Applied to any SDD d, it returns d. ">GShom::id</a> ) </p>

</div>
</div>
<a class="anchor" id="ae4d28fb19857b759f903d4c41a9f0368"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classHom.html">Hom</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open access to <a class="el" href="classHom.html" title="This is the user interface class to manipulate homomorphisms. ">Hom</a> derived class. </p>

</div>
</div>
<a class="anchor" id="adb5ad558aace66b30a6926df2ad5d4f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGHom.html">GHom</a> monotonic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structd3_1_1set.html">d3::set</a>&lt; <a class="el" href="classGHom.html">GHom</a> &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This operator applies its arguments to a node until a fixpoint is reached. </p>
<p>Similar to the fixpoint, but we suppose here that the parameters are commutative <a class="el" href="classAnd.html" title="A commutative composition of n homomorphisms. ">And</a> that any application order converges to the same result Typically this is the property of a base of monotonic&lt; permutations. </p>

</div>
</div>
<a class="anchor" id="ab4c897e330df47a425c599f665cf2ffd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGHom.html">GHom</a> operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGHom.html">GHom</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGHom.html">GHom</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This operator creates an operation that is the composition of two operations. </p>
<p>(h &amp; g) (d) = h( g(d) ) ; Where g,h are homomorphisms and d is a <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams. ">DDD</a>.</p>
<p>Semantics : (h1 &amp; h2) (d) = h1( h2(d) ). </p>

</div>
</div>
<a class="anchor" id="abec978e9de787633d746c1616cf6942c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGHom.html">GHom</a> operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGDDD.html">GDDD</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGHom.html">GHom</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This operator creates an operation that is the intersection of an operation and a constant <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams. ">DDD</a>. </p>
<p>(d1 * h) (d2) = d1 * h(d2) ; Where h is a homomorphism and d1, d2 are <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams. ">DDD</a>.</p>
<p>Semantics : (h * d1) (d) = h(d) * d1 </p>

</div>
</div>
<a class="anchor" id="a1be385b3eedf23b7ba6473cf866aa3a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGHom.html">GHom</a> operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGHom.html">GHom</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGDDD.html">GDDD</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This operator creates an operation that is the intersection of an operation and a constant <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams. ">DDD</a>. </p>
<p>(h * d1) (d2) = h(d2) * d1 ; Where h is a homomorphism and d1, d2 are <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams. ">DDD</a>.</p>
<p>Semantics : (d1 * h) (d) = d1 * h(d) </p>

</div>
</div>
<a class="anchor" id="ad02a172cd3cc33885b9dddb06a1fbfc9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGHom.html">GHom</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGHom.html">GHom</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGHom.html">GHom</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This operator creates an operation that is the union of two operations. </p>
<p>By definition, as homomorphism are linear, (h+g) (d) = h(d) + g(d) ; Where g,h are homomorphisms and d is a <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams. ">DDD</a>.</p>
<p>See also <a class="el" href="classGShom.html#ad8306dea11f1ee748a8e6724c83e5b8d">GShom::add()</a>. This commutative operation computes a homomorphism that evaluates as the sum of two homomorphism.</p>
<p>Semantics : (h1 + h2) (d) = h1(d) + h2(d). </p>

</div>
</div>
<a class="anchor" id="ab64e9a1d83601035b2bafeb53e50989b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGHom.html">GHom</a> operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGHom.html">GHom</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGDDD.html">GDDD</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a set difference constructor, only available for (hom - ddd), not hom - hom as that might not preserve linearity. </p>
<p>(h - d1) (d2) = h(d2) - d1 Where h is a homomorphism and d1, d2 are <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams. ">DDD</a>.</p>
<p>Note that this operation is not commutative, nor is it <em>linear</em>. This means the difference of two linear homomorphisms is not necessarily linear; (h1 - h2) (d) is not necessarily equal to h1(d) - h2(d). Therefore this operator is not defined for composition of two homomorphisms, only for a constant and a homomorphism.</p>
<p>Semantics : (h - d1) (d) = h(d) - d1 </p>

</div>
</div>
<a class="anchor" id="a4c6ed2147a63e065563824e6fb647cee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGHom.html">GHom</a> &amp;&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8f83443dc2ba2ccaa68898193cdf98a2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGHom.html">GHom</a> operator^ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGDDD.html">GDDD</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGHom.html">GHom</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the left concatenantion operator, that adds a constant <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams. ">DDD</a> above the operation. </p>
<p>(d1 ^ h) (d2) = d1 ^ h(d2) Where h is a homomorphism and d1, d2 are <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams. ">DDD</a>.</p>
<p>Note that this is inherently inefficient, the nodes of d1 are constructed, but the result a priori will not contain them, unless h(d) == <a class="el" href="classGSDD.html#a4aa86c09040738368d7fc9fcf35897a9" title="The accepting terminal. This is the basic leaf for accepted sequences. ">GSDD::one</a>.</p>
<p>Semantics : (d1 ^ h) (d) = d1 ^ h(d) </p>

</div>
</div>
<a class="anchor" id="ab8ce94c20f05403c297ff9591ea18919"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGHom.html">GHom</a> operator^ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGHom.html">GHom</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGDDD.html">GDDD</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the right concatenantion operator, that adds a constant <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams. ">DDD</a> below the operation. </p>
<p>(h ^ d1) (d2) = h(d1) ^ d2 Where h is a homomorphism and d1, d2 are <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams. ">DDD</a>.</p>
<p>This is used to construct new nodes, and has the same efficiency issue as left concatenation.</p>
<p>Semantics : (h ^ d1) (d) = h(d) ^ d1 </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="aecc8fb38ce35a0e8e78e0c0a2838ec2e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class__GHom.html">_GHom</a>* GHom::concret</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The real implementation class. </p>
<p>All true operations are delagated on this pointer. Construction/destruction take care of ensuring concret is only instantiated once in memory. </p>

<p>Referenced by <a class="el" href="classGHom.html#a1c7b22844fd8aea4fd559077db4d323d">compose()</a>, <a class="el" href="classGHom.html#aadf148bf7af0b8348f7a596d7ef425f2">eval()</a>, <a class="el" href="class__GHom.html#ac12a737ec835c5a60c0d82068e637777">_GHom::get_concret()</a>, <a class="el" href="classGHom.html#a9f51453eb92ad99341f002d66ca4d64a">get_range()</a>, <a class="el" href="classGHom.html#a2f795ee348657e5fe7a83158bf886919">hash()</a>, <a class="el" href="classHom.html#ad38b3cd22afc500aa8dbc57092399f72">Hom::Hom()</a>, <a class="el" href="classGHom.html#aaa8bf90af18a29f8369d00b74c09e194">invert()</a>, <a class="el" href="classGHom.html#abe91da1f27fdc2b628969cf16215e7bb">is_selector()</a>, <a class="el" href="classGHom.html#aa56524036de8c91ea495e51a715599b5">mark()</a>, <a class="el" href="classGHom.html#a34cc5646112b5ac8ae79fc499e0a5850">negate()</a>, <a class="el" href="classGHom.html#a8cdb66c862560660eff92a569eb55015">operator!=()</a>, <a class="el" href="classGHom.html#a41745b72c666e9718ebf33c20d61f460">operator()()</a>, <a class="el" href="classGHom.html#af6be6ccb7775aeb9072c2c80ff7a7476">operator&lt;()</a>, <a class="el" href="Hom_8cpp.html#a4c6ed2147a63e065563824e6fb647cee">operator&lt;&lt;()</a>, <a class="el" href="classHom.html#a28cd786c9458e8fd4cc314808c8ebb13">Hom::operator=()</a>, <a class="el" href="classGHom.html#abcb92252687a77f94a59dc468e7f2af0">refCounter()</a>, <a class="el" href="classGHom.html#acba7b975d2330f2837e899cb24e71819">skip_variable()</a>, and <a class="el" href="classHom.html#a2b97fb202d69abad9994fe390c49a684">Hom::~Hom()</a>.</p>

</div>
</div>
<a class="anchor" id="a66502d762eb0bbc63dc118d7c7ba8537"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classGHom.html#affb7a403f294a57ca86da7ec0a7c5945">GHom::range_t</a> GHom::full_range = <a class="el" href="classGHom.html#affb7a403f294a57ca86da7ec0a7c5945">GHom::range_t</a>()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The full_range : that targets everyone. </p>

<p>Referenced by <a class="el" href="class__GHom.html#a18280ac9f5c3ed99024092277e661397">_GHom::get_range()</a>.</p>

</div>
</div>
<a class="anchor" id="af17f84f00ffadd24e2f2894e0c8a2207"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classGHom.html">GHom</a> GHom::id</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Elementary homomorphism <a class="el" href="classIdentity.html">Identity</a>, defined as a constant. </p>
<p>id(d) = d </p>

<p>Referenced by <a class="el" href="SHom_8cpp.html#ac72d96d6cdb00d083aeadc1f28efea05">buildUnionParameters()</a>, <a class="el" href="classGHom.html#af12ff552ae92a1a29c608e828ee1a4e7">ccompose()</a>, <a class="el" href="class__GHom.html#a4e4d93ed9bec4d8893a3bfeff8f0d24f">_GHom::compose()</a>, <a class="el" href="classnsMLHom_1_1Identity.html#a552edaf394596cad7f81d17d09f7997d">nsMLHom::Identity::eval()</a>, <a class="el" href="classnsMLHom_1_1GHomAdapter.html#a867939527a1dd05ec3c3db103c8459d3">nsMLHom::GHomAdapter::eval()</a>, <a class="el" href="classStrongMLHom.html#ae49757275123bbc7e640aa146f108ac8">StrongMLHom::eval()</a>, <a class="el" href="classAnd.html#a370d75e75d7cd004de55ba13179c04cb">And::eval()</a>, <a class="el" href="class__GHom.html#aa50ec89149a2416125850f1690cb4d31">_GHom::eval_skip()</a>, <a class="el" href="Hom_8h.html#a33e03b90df48e932ce2ca123ee80eca2">fixpoint()</a>, <a class="el" href="classAdd.html#a6d93147f4cc1944378693edaccb1fca1">Add::get_have_id()</a>, <a class="el" href="classFixpoint.html#ae31be0bcc8612526426636ef952123e0">Fixpoint::has_image()</a>, <a class="el" href="class__GHom.html#a1385269a8a9adb725d5bcb2a144685b1">_GHom::has_image_skip()</a>, <a class="el" href="classMult.html#a0af519e36a32b2b1eefb4684bf0d5cf4">Mult::invert()</a>, <a class="el" href="classAnd.html#a8ab3bc7e4ce24d80079f2d4232e18940">And::invert()</a>, <a class="el" href="classMinus.html#a7f88750cd1634521629c0168882c6372">Minus::invert()</a>, <a class="el" href="classFixpoint.html#a191c5d4cd8a10017c502a16b157504fe">Fixpoint::invert()</a>, <a class="el" href="SHom_8h.html#a74ebe318ba3878ca19e03da4d22e0168">localApply()</a>, <a class="el" href="classConstant.html#a5557611f520e853b1bd6224cd10cd33f">Constant::negate()</a>, <a class="el" href="Hom_8h.html#a0cd509228f69a72bd40c3323376936d0">operator!()</a>, <a class="el" href="Hom_8h.html#ab4c897e330df47a425c599f665cf2ffd">operator&amp;()</a>, <a class="el" href="SHom_8h.html#a7c7e881bdae27f25e5009e0816fc2c20">operator*()</a>, <a class="el" href="class__VarCompState.html#a44785d5162597a860a6aa6fe36a8305e">_VarCompState::phi()</a>, <a class="el" href="class__setVarConst.html#a7e2dc3554c942126899538db8c34bb15">_setVarConst::phi()</a>, <a class="el" href="Hom__Basic_8hh.html#af6ba13d7dfbe9843351ff97900ec1490">varEqVar()</a>, <a class="el" href="Hom__Basic_8hh.html#a690ce7a49d7fd249f29bcc5e1ff8e8c0">varGeqVar()</a>, and <a class="el" href="Hom__Basic_8hh.html#ae3e07a7fd40aeeacfbaccc3dbf6fe074">varLeqVar()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Hom_8h_source.html">Hom.h</a></li>
<li><a class="el" href="Hom_8cpp.html">Hom.cpp</a></li>
<li><a class="el" href="SHom_8cpp.html">SHom.cpp</a></li>
</ul>
</div><!-- contents -->
<hr size="1">
Please <b>comment</b> this page and <b>report errors</b> about it on
<a href="http://ddd.lip6.fr/wiki/RefDocComments">the RefDocComments page</a>.
<br><address style="align: right;"><small>
Generated on Tue Feb 27 2018 17:45:13 for DDD by <a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border=0></a> 1.8.6</small></address>
</body>
</html>
